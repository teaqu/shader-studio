{
  "Template mainImage": {
    "prefix": "tmpl-mainimage",
    "body": [
      "void mainImage(out vec4 fragColor, in vec2 fragCoord) {",
      "\t// Normalized pixel coordinates (from 0 to 1)",
      "\tvec2 uv = fragCoord / iResolution.xy;",
      "",
      "\t// Time varying pixel colour",
      "\tvec3 col = 0.5 + 0.5 * cos(iTime + uv.xyx + vec3(0, 2, 4));",
      "",
      "\t// Output to screen",
      "\tfragColor = vec4(col, 1.0);",
      "}"
    ],
    "description": "Default Shadertoy mainImage template"
  },
  "Template Buffer Pass": {
    "prefix": "tmpl-buffer",
    "body": [
      "// Buffer ${1:A}",
      "void mainImage(out vec4 fragColor, in vec2 fragCoord) {",
      "\tvec2 uv = fragCoord / iResolution.xy;",
      "",
      "\t// Read previous frame",
      "\tvec4 prev = texture(iChannel0, uv);",
      "",
      "\tvec4 col = prev;",
      "\t$0",
      "",
      "\tfragColor = col;",
      "}"
    ],
    "description": "Shadertoy buffer pass template with feedback"
  },
  "Template Raymarch Scene": {
    "prefix": "tmpl-raymarch-scene",
    "body": [
      "float sdSphere(vec3 p, float r) {",
      "\treturn length(p) - r;",
      "}",
      "",
      "float map(vec3 p) {",
      "\tfloat d = sdSphere(p, 1.0);",
      "\td = min(d, p.y + 1.0); // ground plane",
      "\treturn d;",
      "}",
      "",
      "vec3 calcNormal(vec3 p) {",
      "\tconst float h = 0.0001;",
      "\tconst vec2 k = vec2(1, -1);",
      "\treturn normalize(",
      "\t\tk.xyy * map(p + k.xyy * h) +",
      "\t\tk.yyx * map(p + k.yyx * h) +",
      "\t\tk.yxy * map(p + k.yxy * h) +",
      "\t\tk.xxx * map(p + k.xxx * h)",
      "\t);",
      "}",
      "",
      "float rayMarch(vec3 ro, vec3 rd) {",
      "\tfloat t = 0.0;",
      "\tfor (int i = 0; i < 128; i++) {",
      "\t\tvec3 p = ro + rd * t;",
      "\t\tfloat d = map(p);",
      "\t\tif (d < 0.001 || t > 100.0) break;",
      "\t\tt += d;",
      "\t}",
      "\treturn t;",
      "}",
      "",
      "void mainImage(out vec4 fragColor, in vec2 fragCoord) {",
      "\tvec2 uv = (2.0 * fragCoord - iResolution.xy) / iResolution.y;",
      "",
      "\t// Camera",
      "\tvec3 ro = vec3(0.0, 2.0, -5.0);",
      "\tvec3 ta = vec3(0.0, 0.0, 0.0);",
      "\tvec3 ww = normalize(ta - ro);",
      "\tvec3 uu = normalize(cross(ww, vec3(0.0, 1.0, 0.0)));",
      "\tvec3 vv = cross(uu, ww);",
      "\tvec3 rd = normalize(uv.x * uu + uv.y * vv + 1.5 * ww);",
      "",
      "\t// Ray march",
      "\tfloat t = rayMarch(ro, rd);",
      "",
      "\tvec3 col = vec3(0.0);",
      "\tif (t < 100.0) {",
      "\t\tvec3 p = ro + rd * t;",
      "\t\tvec3 n = calcNormal(p);",
      "",
      "\t\t// Material",
      "\t\tvec3 mat = (p.y < -0.99) ? vec3(1.0) : vec3(0.2, 0.4, 0.8);",
      "",
      "\t\t// Lighting",
      "\t\tvec3 lightDir = normalize(vec3(1.0, 1.0, -1.0));",
      "\t\tfloat diff = max(dot(n, lightDir), 0.0);",
      "\t\tfloat amb = 0.1;",
      "\t\tcol = mat * (diff + amb);",
      "\t}",
      "",
      "\t// Gamma correction",
      "\tcol = pow(col, vec3(1.0 / 2.2));",
      "\tfragColor = vec4(col, 1.0);",
      "}"
    ],
    "description": "Complete raymarching scene with SDF, normals, camera, and basic lighting"
  }
}
